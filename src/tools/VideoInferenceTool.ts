import { z } from "zod";
import { defineTool } from "./mod.ts";
import {
  GoogleGenAI,
  createUserContent,
  createPartFromUri,
  File,
} from "@google/genai";

const { createHash } = await import("node:crypto");
const CACHE_FILE = "./cache/video_file_cache.json";
let fileCache: Record<string, string> = {};

async function exists(path: string): Promise<boolean> {
  try {
    await Deno.lstat(path);
    return true;
  } catch {
    return false;
  }
}

async function loadCache() {
  if (await exists(CACHE_FILE)) {
    const content = await Deno.readTextFile(CACHE_FILE);
    fileCache = JSON.parse(content);
  }
}
await loadCache();

async function saveCache() {
  await Deno.writeTextFile(CACHE_FILE, JSON.stringify(fileCache, null, 2));
}

async function getVideoHash(videoPath: string): Promise<string> {
  const data = await Deno.readFile(videoPath);
  const hash = createHash("md5");
  hash.update(data);
  return hash.digest("hex");
}

export const VideoInferenceTool = defineTool({
  name: "video_inference",
  description: `Ask a question about a local video file by uploading it to Gemini (via GoogleGenAI), and querying it with a user question.

The tool automatically handles file caching using an MD5 hash to avoid re-uploading the same video again.

If the video file is too large and a video compression tool is available, it will prefer compressing the video first and use the compressed version for analysis.

Parameters:
- videoPath: Local path to a video file (e.g., ./downloads/video.mp4)
- question: A user-defined question about the content of the video

The tool uploads the video (if not cached), waits for the file to become ACTIVE, and then calls Gemini's 'generateContent' with the video and question.`,

  parameters: z.object({
    videoPath: z.string().describe("Local path to the video file"),
    question: z.string().describe("A question to ask about the video content"),
  }),
  execute: async ({ videoPath, question }) => {
    const genAI = new GoogleGenAI({ apiKey: Deno.env.get("GOOGLE_API_KEY") });
    const videoHash = await getVideoHash(videoPath);

    let fileUri: string;
    let fileId: string;
    let video_file: File;

    if (fileCache[videoHash]) {
      fileUri = fileCache[videoHash];
      fileId = fileUri.split("/").pop()!;
      video_file = await genAI.files.get({ name: fileId });
    } else {
      video_file = await genAI.files.upload({ file: videoPath });

      if (!video_file.uri) {
        return "❌ Upload failed: file URI is undefined.";
      }

      fileUri = video_file.uri;
      fileCache[videoHash] = fileUri;
      await saveCache();
    }

    while (video_file.state !== "ACTIVE") {
      await new Promise((res) => setTimeout(res, 5000));
      if (!video_file.name) {
        return "❌ File name is undefined while waiting for ACTIVE state.";
      }
      video_file = await genAI.files.get({ name: video_file.name });
    }

    if (!video_file.uri || !video_file.mimeType) {
      return "❌ File upload failed or returned no URI/mimeType.";
    }

    const response = await genAI.models.generateContent({
      model: "gemini-2.5-flash",
      contents: createUserContent([
        createPartFromUri(video_file.uri, video_file.mimeType),
        question,
      ]),
    });

    if (!response.text) {
      return "❌ No response generated by Gemini model.";
    }

    return response.text;
  },
});
