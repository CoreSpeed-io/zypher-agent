# Zypher Agent Project Rules & Learnings

## Code Organization
- Keep related functionality together
- Use helper functions to reduce code duplication
- Normalize paths consistently across the codebase
- Use clear naming: `getWorkspaceDataDir()` for the data directory specific to a workspace, not the workspace itself

## Git Practices
- Use conventional commits (feat:, fix:, refactor:, etc.)
- Write descriptive commit messages explaining the why, not just the what
- Keep commits focused and atomic

## Environment Variables
- Use .env for local development
- Document all required and optional variables in .env.example
- Keep sensitive information out of version control

## Dependencies
- Use bun as package manager
- Lock dependency versions for consistency
- Document major dependencies in README.md

## Code Style
- Use TypeScript for type safety
- Implement proper error handling
- Add descriptive comments for complex logic
- Use Zod for runtime type validation
- Always use asynchronous filesystem operations (fs/promises) to avoid blocking the event loop
- Refactor repetitive code patterns into helper methods to improve maintainability
- Use private helper methods for internal functionality that's used in multiple places
- Always check for undefined objects before accessing their properties

## Testing Framework
- Vitest is the preferred testing framework
- Run tests in watch mode during development
- Ensure tests are deterministic and isolated

## Testing
- Co-locate test files with source files for better organization
- Use `.test.ts` suffix for test files
- Enable test mode when applying git diffs to prevent actual file changes during tests
- Ensure test coverage for edge cases (empty files, new files, etc.)

## Checkpoint System
- Store checkpoints in `$HOME/.zypher/workspace_hash/checkpoints` as a separate Git repository
- Use `--git-dir` and `--work-tree` flags to interact with the repository while keeping the working directory in the project root
- Always use the getGitCommand() helper function for all Git operations to ensure consistent flags
- Store checkpoint metadata in commit messages with a consistent prefix (CHECKPOINT:)
- Create checkpoints automatically before each task execution
- Include checkpoint references in user task messages to enable easy rollback
- Use server-sent events to stream checkpoint creation and task execution events to clients
- Provide a single API endpoint for applying checkpoints, as message history already contains checkpoint references
- Always create a backup before applying a checkpoint to allow for recovery if needed
- Mark advice-only checkpoints with an "(advice-only)" suffix in the commit message
- Use the `--allow-empty` flag with Git to create commits even when there are no file changes
- Use the files array to determine if a checkpoint contains changes (empty array = advice-only)
- Use `git status` to check if a repository exists and is valid, rather than checking for the .git directory and then validating with a separate command
- Checkpoint creation should always be handled by the ZypherAgent class, not by the API server or CLI
- ZypherAgent is responsible for applying checkpoints and updating message history to discard messages beyond the applied checkpoint
- When applying a checkpoint, exclude the checkpoint message itself and all subsequent messages from history, as the checkpoint message represents the state after which we want to roll back

## API Server
- The API server should be implemented in bin/api-server.ts
- The API server should rely on the ZypherAgent class for core functionality
- The API server should use server-sent events (SSE) to stream responses back to the client
- The API server should provide endpoints for managing messages, running tasks, and working with checkpoints
- Stream event types should use descriptive names that reflect their purpose (e.g., 'content_delta' for incremental content updates)
- Authentication is currently disabled for development simplicity

## Anthropic API Integration
- Always use `response.stop_reason === 'tool_use'` to detect when Claude wants to use a tool, not by filtering content blocks
- Process all tool use blocks in the response content when stop_reason is 'tool_use'
- Handle different stop reasons appropriately ('tool_use', 'max_tokens', etc.)
- When implementing streaming with the Anthropic API:
  - Use the `messages.stream()` method instead of `messages.create()`
  - Process the various event types: content_block_start, content_block_delta, message_stop, etc.
  - Always null-check objects before accessing their properties to avoid TypeScript errors
  - Maintain a current content array to build the complete message during streaming
  - Retrieve the final message using `stream.finalMessage()` to get stop reasons and process tool calls
  - Separate streaming handlers (real-time updates) from message handlers (complete messages)
  - For TypeScript imports of type definitions, use `import type` syntax when verbatimModuleSyntax is enabled
  - Design streaming handler interfaces for simplicity, focusing on what consumers need (content, events) rather than internal implementation details
  - Provide backward compatibility by making non-streaming methods delegate to streaming ones with appropriate defaults
  - Avoid API redundancy: don't have separate handlers for messages and streaming when one can handle both
  - Use interface composition that matches natural usage patterns (onContent, onMessage)
  - Derive specific events (like tool usage) from message content rather than creating redundant event handlers
  - Reuse existing handler mechanisms rather than creating parallel implementations
  - Prefer adapter patterns over temporary method overriding for interface compatibility
  - Use `runTaskWithStreaming` as the primary implementation for real-time content deltas and `runTaskLoop` for whole-message updates only
  - Use onMessage for message boundary notifications instead of waiting for the entire streaming process to complete
  - Prefer standard async/await to determine completion rather than using completion callbacks
  - Use standard JavaScript try/catch for error handling rather than callback-based error handlers to reduce API complexity
  - Avoid nested try/catch blocks when the inner block is just re-throwing the error anyway
  - Use clear, descriptive names for streaming events that reflect their purpose (e.g., 'content_delta' for content updates)